const OpenAIClient = require('./openaiClient');
const ColumnMappingService = require('../semanticLayer/columnMappingService');
const PythonExecutor = require('../pythonExecutor');

/**
 * GPT-4.1 Agent Orchestrator Service
 * Simplified version for testing - focuses on core analysis functionality
 */
class GPT4AgentOrchestrator {
  constructor() {
    this.client = new OpenAIClient();
    this.columnMapper = new ColumnMappingService();
    this.pythonExecutor = new PythonExecutor();
    
    // Agent management
    this.activeAgents = new Map();
    this.agentCommunications = [];
    this.semanticModels = new Map();
  }

  /**
   * Main analysis method - orchestrates multi-agent workflow with GPT-4.1
   */
  async analyzeData(data, analysisType, userContext, identifier = 'default') {
    const startTime = Date.now();
    
    try {
      // Security and validation checks
      this.client.checkRateLimit(identifier);
      const sanitizedData = this.client.sanitizeData(data);
      const sanitizedContext = this.client.sanitizeUserContext(userContext);

      console.log(`🤖 Starting GPT-4.1 Agent Orchestration for: "${sanitizedContext}"`);
      console.log(`📊 Dataset: ${sanitizedData.length} rows, ${Object.keys(sanitizedData[0] || {}).length} columns`);

      // Build orchestrated analysis messages
      const messages = this.buildOrchestrationMessages(sanitizedData, analysisType, sanitizedContext);
      
      // Send to OpenAI GPT-4.1 API
      const response = await this.client.sendMessage(messages, {
        model: 'gpt-4-1106-preview',
        maxTokens: 4000,
        temperature: 0.1
      });

      if (!response.choices || response.choices.length === 0) {
        throw new Error('Empty response from GPT-4.1 Agent Orchestrator');
      }

      const analysisText = response.choices[0].message.content;
      console.log('📝 Received orchestrated analysis from GPT-4.1');

      // Extract Python code from response
      const pythonCode = this.extractPythonCode(analysisText);
      
      // Execute Python code to get actual results
      let resultsTable = null;
      let visualization = null;
      let pythonResults = null;
      
      // Execute Python code - NO FALLBACKS per CLAUDE.md policy
      if (pythonCode && pythonCode.code) {
        console.log('🐍 Executing Python code to generate results...');
        pythonResults = await this.pythonExecutor.executePythonCode(
          pythonCode.code, 
          sanitizedData, 
          sanitizedContext
        );
        
        if (pythonResults.success && pythonResults.results) {
          // Use Python execution results for table and visualization
          resultsTable = this.createTableFromPythonResults(pythonResults);
          visualization = this.createVisualizationFromPythonResults(pythonResults, sanitizedContext);
        } else {
          // FAIL PROPERLY - no fallback logic allowed
          throw new Error(`Python execution failed: ${pythonResults.error || 'Unknown execution error'}`);
        }
      } else {
        // FAIL PROPERLY - no fallback logic allowed  
        throw new Error('No executable Python code generated by GPT-4.1');
      }

      // Generate refined question suggestions using multi-agent approach
      const refinedQuestions = this.generateAgentRefinedQuestions(sanitizedData, sanitizedContext, analysisText);
      
      const duration = Date.now() - startTime;

      return {
        success: true,
        analysis: analysisText,
        python_code: pythonCode,
        results_table: resultsTable,
        visualization: visualization,
        refined_questions: refinedQuestions,
        agent_communications: this.agentCommunications.slice(-5), // Last 5 communications
        semantic_insights: this.extractSemanticInsights(analysisText),
        python_execution: pythonResults,
        metadata: {
          model: 'gpt-4-1106-preview',
          orchestration_type: 'multi-agent',
          agents_active: this.activeAgents.size,
          rows_analyzed: sanitizedData.length,
          analysis_type: analysisType,
          processing_time: duration,
          python_executed: pythonResults?.success || false,
          python_execution_time: pythonResults?.execution_time || 0,
          timestamp: new Date().toISOString(),
          token_usage: {
            prompt_tokens: response.usage?.prompt_tokens || 0,
            completion_tokens: response.usage?.completion_tokens || 0,
            total_tokens: response.usage?.total_tokens || 0
          }
        }
      };

    } catch (error) {
      console.error('GPT-4.1 Agent Orchestration error:', error.message);
      
      let clientError = 'AI agent orchestration failed. Please try again.';
      
      if (error.message.includes('Rate limit')) {
        clientError = error.message;
      } else if (error.message.includes('not initialized')) {
        clientError = 'AI orchestration service unavailable.';
      }

      return {
        success: false,
        error: clientError,
        timestamp: new Date().toISOString()
      };
    }
  }

  // Build orchestration messages for multi-agent analysis
  buildOrchestrationMessages(data, analysisType, userContext) {
    const dataStructure = this.analyzeDataStructure(data);
    const sampleData = data.slice(0, 5);
    
    const systemMessage = {
      role: "system",
      content: `You are the central coordinator in a multi-agent data analysis system powered by GPT-4.1. You orchestrate specialized data analysis agents:

- Statistical Analysis Agent: Advanced statistical modeling and hypothesis testing
- Business Intelligence Agent: Strategic insights and KPI analysis
- Predictive Analytics Agent: Forecasting and trend analysis
- Visualization Agent: Data storytelling and chart recommendations

You coordinate these agents to provide comprehensive, multi-faceted analysis with superior reasoning capabilities.`
    };

    const userMessage = {
      role: "user",
      content: `Coordinate multi-agent analysis of this business dataset:

DATASET OVERVIEW:
- Total Records: ${data.length}
- Columns: ${dataStructure.columns.join(', ')}
- Numeric: ${dataStructure.numericColumns.join(', ') || 'None'}
- Categorical: ${dataStructure.categoricalColumns.join(', ') || 'None'}

SAMPLE DATA:
${JSON.stringify(sampleData, null, 2)}

USER REQUEST: "${userContext}"

CRITICAL REQUIREMENTS:
1. Generate EXECUTABLE Python code using pandas that directly answers the user's question
2. The Python code should process the data to get specific results (not generic summaries)
3. Include the executable Python code in \`\`\`python code blocks
4. The code should output results as a pandas DataFrame or specific values
5. Focus on the user's actual question - if they ask for "top 5 offices in 2024", filter and rank accordingly

EXPECTED OUTPUT FORMAT:
```python
import pandas as pd

# Load the provided dataset 
df = pd.DataFrame(data)

# [Your specific analysis code here to answer: "${userContext}"]
# Example: df_filtered = df[df['year'] == 2024]
# Example: top_5 = df_filtered.groupby('office').sum().nlargest(5, 'revenue')

# Return the final result
result = # your final dataframe or result
print(result)
```

Then provide your analysis interpretation explaining what the code does and what insights it reveals.`
    };
    
    return [systemMessage, userMessage];
  }

  // Helper methods
  analyzeDataStructure(data) {
    if (!data || data.length === 0) return { columns: [], numericColumns: [], categoricalColumns: [], dateColumns: [] };
    
    const columns = Object.keys(data[0]);
    const sampleRow = data[0];
    const profile = {
      columns: columns,
      numericColumns: [],
      categoricalColumns: [],
      dateColumns: []
    };
    
    columns.forEach(col => {
      const colLower = col.toLowerCase();
      const sampleValue = sampleRow[col];
      
      if (colLower.includes('date') || colLower.includes('time')) {
        profile.dateColumns.push(col);
      } else if (typeof sampleValue === 'number' || (!isNaN(parseFloat(sampleValue)) && isFinite(sampleValue))) {
        profile.numericColumns.push(col);
      } else {
        const values = data.slice(0, 100).map(row => row[col]).filter(v => v != null);
        const uniqueValues = [...new Set(values)];
        if (uniqueValues.length <= Math.min(20, data.length * 0.5) && uniqueValues.length > 1) {
          profile.categoricalColumns.push(col);
        }
      }
    });
    
    return profile;
  }

  extractPythonCode(text) {
    const codeBlocks = text.match(/```python\n([\s\S]*?)\n```/g);
    if (codeBlocks && codeBlocks.length > 0) {
      const code = codeBlocks[0].replace(/```python\n/, '').replace(/\n```/, '');
      return {
        code: code,
        executable: code.length > 0
      };
    }
    return null;
  }

  createAnalysisSummaryTable(data, analysisText) {
    if (!data || data.length === 0) return null;
    
    return {
      title: "GPT-4.1 Agent Analysis Summary",
      columns: Object.keys(data[0]),
      rows: data.slice(0, 10).map(row => Object.values(row)),
      totalRows: data.length,
      analysisHighlights: this.extractKeyFindings(analysisText)
    };
  }

  createTableFromPythonResults(pythonResults) {
    if (!pythonResults || !pythonResults.success) return null;
    
    const { results } = pythonResults;
    
    if (results.type === 'dataframe' && results.data && results.columns) {
      return {
        title: "Python Analysis Results",
        columns: results.columns,
        data: results.data, // Use the data format expected by frontend
        rows: results.data.map(row => results.columns.map(col => row[col])), // Also provide rows format
        totalRows: results.data.length,
        source: "Python execution results"
      };
    } else if (results.type === 'value') {
      return {
        title: "Analysis Result",
        columns: ["Result"],
        data: [{ "Result": results.data }],
        rows: [[results.data]],
        totalRows: 1,
        source: "Python execution value"
      };
    }
    
    return null;
  }

  createVisualizationFromPythonResults(pythonResults, userContext) {
    if (!pythonResults || !pythonResults.success) return null;
    
    const { results } = pythonResults;
    
    if (results.type === 'dataframe' && results.data && results.columns) {
      const data = results.data;
      const columns = results.columns;
      
      // Find the best columns for visualization
      const numericColumns = columns.filter(col => {
        return data.some(row => typeof row[col] === 'number' || (!isNaN(parseFloat(row[col])) && isFinite(row[col])));
      });
      
      const labelColumns = columns.filter(col => !numericColumns.includes(col));
      
      if (numericColumns.length > 0) {
        const labelCol = labelColumns[0] || 'index';
        const valueCol = numericColumns[0];
        
        const chartData = data.slice(0, 10).map((row, index) => ({
          label: row[labelCol] ? String(row[labelCol]) : `Item ${index + 1}`,
          value: parseFloat(row[valueCol]) || 0
        }));
        
        return {
          type: 'bar_chart',
          title: `${userContext} - Results`,
          data: chartData
        };
      }
    }
    
    return this.createBasicVisualization(pythonResults.results.data || [], "Python Analysis Results");
  }

  createBasicVisualization(data, title) {
    if (!data || data.length === 0) return null;
    
    const columns = Object.keys(data[0] || {});
    const numericColumns = columns.filter(col => 
      typeof data[0][col] === 'number' || !isNaN(parseFloat(data[0][col]))
    );
    
    if (numericColumns.length > 0) {
      return {
        type: 'bar_chart',
        title: title,
        data: data.slice(0, 10).map((row, index) => ({
          label: `Row ${index + 1}`,
          value: parseFloat(row[numericColumns[0]]) || 0
        }))
      };
    }
    
    return {
      type: 'table',
      title: title,
      message: 'Agent-orchestrated analysis available'
    };
  }

  generateAgentRefinedQuestions(data, userContext, analysisText) {
    const dataProfile = this.analyzeDataStructure(data);
    const refinedQuestions = [];
    
    // Multi-agent question generation
    if (dataProfile.numericColumns.length > 1) {
      refinedQuestions.push({
        question: `What advanced statistical relationships exist between ${dataProfile.numericColumns.slice(0, 2).join(' and ')}?`,
        reason: "Statistical Analysis Agent recommendation",
        agent: "Statistical"
      });
    }
    
    if (dataProfile.categoricalColumns.length > 0) {
      refinedQuestions.push({
        question: `What strategic business insights can be derived from ${dataProfile.categoricalColumns[0]} segments?`,
        reason: "Business Intelligence Agent recommendation", 
        agent: "BI"
      });
    }
    
    refinedQuestions.push({
      question: "What predictive patterns and future trends does the data reveal?",
      reason: "Predictive Analytics Agent recommendation",
      agent: "Predictive"
    });
    
    return refinedQuestions.slice(0, 3);
  }

  extractSemanticInsights(analysisText) {
    return {
      keyTerms: this.extractKeyTerms(analysisText),
      businessConcepts: this.extractBusinessConcepts(analysisText),
      relationships: this.extractRelationships(analysisText)
    };
  }

  extractKeyFindings(analysisText) {
    const sentences = analysisText.split('.').filter(s => s.length > 20);
    return sentences.slice(0, 3).map(s => s.trim());
  }

  extractKeyTerms(text) {
    const terms = text.match(/\b[A-Z][A-Za-z]+\b/g) || [];
    return [...new Set(terms)].slice(0, 5);
  }

  extractBusinessConcepts(text) {
    const businessTerms = ['revenue', 'profit', 'growth', 'customer', 'market', 'trend', 'performance', 'efficiency'];
    const found = businessTerms.filter(term => text.toLowerCase().includes(term));
    return found.slice(0, 3);
  }

  extractRelationships(text) {
    const relationships = text.match(/(correlat|associat|relationship|impact|effect|influence)/gi) || [];
    return relationships.slice(0, 2);
  }

  // Health check and status methods
  async healthCheck() {
    return await this.client.healthCheck();
  }

  getStatus() {
    const clientStatus = this.client.getStatus();
    return {
      service: 'GPT-4.1 Agent Orchestration',
      ...clientStatus,
      active_agents: this.activeAgents.size,
      communications_count: this.agentCommunications.length,
      semantic_models: this.semanticModels.size
    };
  }
}

// Export singleton instance
const gpt4AgentOrchestrator = new GPT4AgentOrchestrator();
module.exports = gpt4AgentOrchestrator;